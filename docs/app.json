[{"name":"app.R","content":".gen_grid <- function(dim = 16, fill_val = \"#E5E5E5\") {\n  matrix(rep(fill_val, dim ^ 2), dim)\n}\n\n.convert_hex2pxltrx <- function(mat) {\n  unique_colours <- unique(as.character(mat))\n  colour_lookup <- setNames(seq(length(unique_colours)) - 1, unique_colours)\n  new_mat <- matrix(colour_lookup[mat], ncol(mat))\n  attr(new_mat, \"colours\") <- unique_colours\n  class(new_mat) <- \"pixeltrix\"\n  new_mat\n}\n\n.gen_image <- function(mat) {\n\n  mat_pxltrx <- .convert_hex2pxltrx(mat)\n  mat_colours <- attributes(mat_pxltrx)[[\"colours\"]]\n  n_colours <- length(mat_colours)\n  mat_invert <- t(mat_pxltrx[seq(nrow(mat_pxltrx), 1), ])\n\n  graphics::par(mar = rep(0, 4))\n\n  graphics::image(\n    mat_invert,\n    zlim = c(0, n_colours - 1),\n    col  = mat_colours,\n    axes = FALSE,\n    xlab = \"\",\n    ylab = \"\"\n  )\n\n  graphics::abline(v = .gen_ablines(mat, \"x\"), col = \"white\")\n  graphics::abline(h = .gen_ablines(mat, \"y\"), col = \"white\")\n\n}\n\n.gen_ablines <- function(mat, dim = c(\"x\", \"y\")) {\n\n  dim_n <- ncol(mat)\n  if (dim == \"y\") dim_n <- nrow(mat)\n\n  if (dim_n > 1) {\n    dim_unit  <- 1 / (dim_n - 1)  # width of one pixel\n    dim_lines <- seq(  # min/max pixel centres at -1,1, but there's 'overhang'\n      0 - dim_unit - (dim_unit / 2),  # add half a pixel overhang at min\n      1 + dim_unit + (dim_unit / 2),  # add half a pixel overhang at max\n      dim_unit\n    )\n  }\n\n  dim_lines\n\n}\n\n.get_pixel_coords <- function(mat, point_coords) {\n\n  # Pixel centres\n  x_n    <- ncol(mat)  # number of pixels in the x dimension\n  x_unit <- 1 / (x_n - 1)  # x width of pixels\n  x_mids <- seq(0, 1, x_unit)  # full set of pixel centres on x axes\n  y_n    <- nrow(mat)\n  y_unit <- 1 / (y_n - 1)\n  y_mids <- seq(0, 1, y_unit)\n\n  # Calculate distances xy from clicked point to pixel centres\n  x_diffs <- abs(point_coords[[\"x\"]] - x_mids)\n  y_diffs <- rev(abs(point_coords[[\"y\"]] - y_mids))\n\n  # Identify pixel closest to click\n  pixel_coords <- list(x = which.min(x_diffs), y = which.min(y_diffs))\n\n  pixel_coords  # list with values 'x' and 'y' giving pixel location on grid\n\n}\n\n.gen_updated_pixel_matrix <- function(mat, pixel_coords, selected_colour) {\n  new_value <- selected_colour\n  mat[pixel_coords[[\"y\"]], pixel_coords[[\"x\"]]] <- new_value\n  mat\n}\n\n.gen_bot_pixel_matrix <- function() {\n\n  rand_colour <- sample(c(\"#FF0000\", \"#00FF00\", \"#0000FF\", \"#000000\"), 1)\n  colour_lookup <- setNames(c(\"#E5E5E5\", rand_colour), 0:1)\n\n  vec <- sample(c(0, 1), 16 ^ 2, TRUE)\n\n  if (sample(c(TRUE, FALSE), 1, prob = c(0.1, 0.9))) {\n    vec <- c(\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,\n      0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,\n      0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0,\n      0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0,\n      0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0,\n      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0,\n      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0,\n      0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0,\n      0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0,\n      0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0,\n      0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,\n      0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,\n      0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    )\n  }\n\n  matrix(colour_lookup[as.character(vec)], 16)\n\n}\n\nui <- shiny::fluidPage(\n  htmltools::h1(\"little pixel fun zone\"),\n  htmltools::p(\n    \"by\",\n    htmltools::a(\"matt\", href = \"https://www.matt-dray.com\", target = \"_blank\")\n  ),\n  shiny::plotOutput(\n    \"pixel_grid\",\n    380,\n    380,\n    shiny::clickOpts(\"clicked_point\", TRUE)\n  ),\n  htmltools::br(),\n  colourpicker::colourInput(\n    \"selected_colour\",\n    NULL,\n    \"black\",\n    palette = \"limited\",\n    returnName = TRUE,\n    width = 120\n  ),\n  shiny::actionButton(\"button_undo\", shiny::icon(\"rotate-left\")),\n  shiny::actionButton(\"button_fill\", shiny::icon(\"fill-drip\")),\n  shiny::actionButton(\"button_robot\", shiny::icon(\"robot\")),\n  shiny::downloadButton(\n    \"button_download\",\n    NULL,\n    icon = shiny::icon(\"floppy-disk\")\n  )\n)\n\nserver <- function(input, output, session) {\n\n  # Reactives\n\n  pixel_matrices <- shiny::reactiveValues(slot1 = .gen_grid(16, \"#E5E5E5\"))\n\n  point_coords <- shiny::reactive({\n    list(x = input$clicked_point[[\"x\"]], y = input$clicked_point[[\"y\"]])\n  })\n\n  pixel_coords <- shiny::reactive({\n    .get_pixel_coords(pixel_matrices[[\"slot1\"]], point_coords())\n  })\n\n  undo_button_icon <- shiny::reactiveVal(\"rotate-left\")\n\n  # Observers\n\n  shiny::observeEvent(input$clicked_point, {\n    matrix_updated <- .gen_updated_pixel_matrix(\n      shiny::isolate(pixel_matrices[[\"slot1\"]]),\n      pixel_coords(),\n      input$selected_colour\n    )\n    pixel_matrices[[\"slot2\"]] <- pixel_matrices[[\"slot1\"]]\n    pixel_matrices[[\"slot1\"]] <- matrix_updated\n  })\n\n  shiny::observeEvent(\n    input$button_undo, {\n\n      # Switch 'memory' slots\n      slot1 <- pixel_matrices[[\"slot1\"]]\n      slot2 <- pixel_matrices[[\"slot2\"]]\n      pixel_matrices[[\"slot2\"]] <- slot1\n      pixel_matrices[[\"slot1\"]] <- slot2\n\n      # Invert undo/redo icon\n\n      current_icon <- undo_button_icon()\n      if (current_icon == \"rotate-left\") undo_button_icon(\"rotate-right\")\n      if (current_icon == \"rotate-right\") undo_button_icon(\"rotate-left\")\n\n      shiny::updateActionButton(\n        inputId = \"button_undo\",\n        icon = shiny::icon(undo_button_icon())\n      )\n\n    })\n\n  shiny::observeEvent(input$button_fill, {\n    matrix_filled <- .gen_grid(16, input$selected_colour)\n    pixel_matrices[[\"slot2\"]] <- pixel_matrices[[\"slot1\"]]\n    pixel_matrices[[\"slot1\"]] <- matrix_filled\n  })\n\n  shiny::observeEvent(input$button_robot, {\n    matrix_by_bot <- .gen_bot_pixel_matrix()\n    pixel_matrices[[\"slot2\"]] <- pixel_matrices[[\"slot1\"]]\n    pixel_matrices[[\"slot1\"]] <- matrix_by_bot\n  })\n\n  # Outputs\n\n  output$pixel_grid <- shiny::renderPlot({\n    .gen_image(pixel_matrices[[\"slot1\"]])\n  })\n\n  output$button_download <- downloadHandler(\n    filename = function() {\n      paste0(format(Sys.time(), \"%Y-%m-%d-%H%M%S\"), \"_treasured-art.png\")\n    },\n    content = function(file) {\n      ppi <- 300\n      png(file, width = 4 * ppi, height = 4 * ppi, res = ppi)\n      .gen_image(pixel_matrices[[\"slot1\"]])\n      dev.off()\n    }\n  )\n\n}\n\nshiny::shinyApp(ui, server)\n","type":"text"}]
